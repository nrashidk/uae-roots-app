Analysis of FamilyEcho.com vs. Your Family Tree App
Based on a review of FamilyEcho.com (via web searches, user descriptions, Q&A forums, and visual examples from user-shared screenshots and discussions), here's a high-level comparison of their family tree visualization and connection system to your app's code (drawing from App-old.jsx, App (3).jsx, and related files like App.css). FamilyEcho is a drag-and-drop, centered-on-person tool that emphasizes clean, non-overlapping layouts with standardized connection lines to avoid "confusing crossing lines" (as noted in their FAQs). It supports up to 15 generations per branch, prioritizes blood relations, and uses semi-automatic layout with manual adjustments.
Key Features of FamilyEcho's Connections and Layout (From Review)

Layout Style: Top-down hierarchical (pedigree chart). Centers on a selected person. Parents/generations above, children below. Spouses side-by-side (configurable left/right, often wife left in Western layouts). Siblings horizontally spaced under a "sibling bar." Automatic initial positioning to minimize overlaps, with drag-to-reposition. RTL support isn't native but can be mirrored.
Connection Drawing:

Spouses/Partners: Horizontal straight line between box centers (thick solid line for current, dashed/thinner for ex-partners).
Parent-Child: Vertical line from the middle of the parent horizontal bar down to a horizontal "sibling bar" (connects all siblings), then short vertical stubs to each child's top center. Diagonal if needed to avoid crosses.
Siblings: No direct lines; implied via the sibling bar (horizontal line under parents).
Other (e.g., non-biological): Gray/dotted lines.
Lines are SVG-based, straight or with gentle curves/bends (rounded corners in some exports). Thickness: thick (current relations), medium (parents/siblings), thin/dashed (others). Colors: Black/gray default, customizable per type.


Interactivity: Drag lines from a person icon to connect (e.g., click "Add Spouse" then drag). Zoom/pan with mouse wheel/drag. Auto-expand branches via tabs or generation sliders (parents/children/others).
Visualization Tech (Inferred): Likely custom SVG canvas with a layout algorithm (DAG-based for multiple parents/remarriages). No public libs visible, but behavior matches simple force-directed or recursive tree layout (e.g., like d3-hierarchy but lightweight).
Strengths for Your Use Case: Handles complex families without overlaps; exports clean PDFs with lines intact. Arabic/RTL: Users report manual mirroring works, but no native bidi.

Comparison to Your App
Your app (from code snippets) has a solid foundation: draggable cards (tree-canvas with cursor: grab), zoom/pan (via zoom, panOffset, useRef for mouse events), relationship types (REL constants), and states for people/relationships. Cards are positioned absolutely (inferred from drag logic), with potential for SVG overlays. However:

Strengths: RTL Arabic support (via CSS direction: rtl), customizable display/styling options (e.g., displayOptions, stylingOptions), form-based adding (better than drag-connect for Arabic input). Pan/zoom is smooth with global listeners.
Gaps vs. FamilyEcho:

Layout: Manual drag-only; no auto-positioning, leading to overlaps/crossing lines. FamilyEcho auto-spaces generations horizontally/vertically.
Connections: Likely missing or basic <line> elements (not shown in snippets). No sibling bars, curved paths, or type-based styles (e.g., thick for partners). Positions not transformed for zoom/pan.
Relationship Handling: Your REL types match (partner, parent-child, sibling), but no enforcement of family units (e.g., grouping spouses + children).
Interactivity: No drag-to-connect; adding is form-based (good for data entry, but add visual feedback). No generation expanders.
Visualization: Cards use colors (maleBoxColor, etc.), but lines aren't styled/differentiated. No avoidance of crosses.
Performance/Complexity: Your REPL-like state is fine for small trees; FamilyEcho handles large via branching limits.



Your connections "not working properly" likely stems from: (1) lines not rendered or positioned relative to card centers, (2) no transform for zoom/pan, (3) straight lines crossing due to manual positions.
Suggested Changes to Match FamilyEcho
Implement these incrementally. Focus on auto-layout first (biggest gap), then connections. Add to App.jsx (merge from App-old.jsx and App (3).jsx). No new deps needed (use native SVG + math). Test with your existing people (add x, y if missing) and relationships (array of {id, type: REL.X, person1Id, person2Id}).


Add Position Storage and Basic Card Rendering (If Missing)

Ensure each person has x, y (updated on drag).
In tree-canvas (from CSS: position: relative; overflow: hidden), render cards as absolute-positioned divs.

jsx// In App.jsx, update people state to include positions (default to 0)
const [people, setPeople] = useState([]); // e.g., [{id: 1, name: 'أحمد', x: 0, y: 0, gender: 'male', ...}]

// Drag handler (expand your existing useEffect)
const handleCardDrag = (personId, e) => {
  // ... your existing logic to update person x,y
  setPeople(prev => prev.map(p => p.id === personId ? { ...p, x: newX, y: newY } : p));
};

// Render cards in tree view (inside <div className="tree-canvas" ref={canvasRef}>)
{people.map(person => (
  <div
    key={person.id}
    className={`absolute bg-${person.gender === 'male' ? 'blue' : 'pink'}-100 p-2 rounded shadow`} // Use your stylingOptions
    style={{
      left: person.x * zoom + panOffset.x,
      top: person.y * zoom + panOffset.y,
      width: CARD.w * zoom,
      height: CARD.h * zoom,
      transform: `scale(${zoom})`, // Apply zoom per card if needed
      cursor: 'grab',
      // ... displayOptions for content (name, dates, etc.)
    }}
    draggable
    onDragStart={(e) => handleCardDrag(person.id, e)} // Simplified; use your ref logic
  >
    <div className="arabic-text text-sm">{person.name}</div> {/* Add more fields */}
  </div>
))}


Implement Auto-Layout Algorithm (Core to FamilyEcho's Clean Look)

Add a "Auto-Layout" button (using your Button component). Centers on selectedPerson, positions generations top-down (RTL: right-to-left spacing).
Simple recursive function: Treat as DAG, compute levels (ancestors negative, descendants positive). Space horizontally per level (e.g., 200px apart). Group spouses side-by-side (female right in RTL? Configurable via generationOptions.leftPartner).
Handles siblings via horizontal offset under parents.

jsx// Add to state
const [layoutRoot, setLayoutRoot] = useState(null);

// Auto-layout function (call on button click: computeLayout(selectedPerson?.id))
const computeLayout = (rootId) => {
  if (!rootId) return;
  const newPeople = [...people];
  const levelSpacing = 150; // Vertical generations
  const siblingSpacing = 180; // Horizontal within level
  const spouseOffset = 80; // Side-by-side

  // Helper: Get children/parents from relationships
  const getConnected = (id, type) => relationships
    .filter(r => r.type === type && (r.person1Id === id || r.person2Id === id))
    .map(r => r.person1Id === id ? r.person2Id : r.person1Id);

  // Recursive position: level (y), startX for subtree
  const positionSubtree = (personId, level, startX = 0, isSpouse = false) => {
    const person = newPeople.find(p => p.id === personId);
    if (!person) return 0; // Width of subtree

    person.level = level;
    person.x = startX + (isSpouse ? spouseOffset : 0); // Spouses offset
    person.y = level * levelSpacing;

    // Position children (recursion)
    const children = getConnected(personId, REL.PARENT_CHILD).filter(childId => 
      relationships.some(r => r.type === REL.PARENT_CHILD && r.person2Id === personId && r.person1Id === childId) // Assume person1=parent
    );
    let childStartX = startX - (children.length * siblingSpacing / 2); // Center under parent
    let subtreeWidth = 0;
    children.forEach(child => {
      const childWidth = positionSubtree(child, level + 1, childStartX, false);
      childStartX += siblingSpacing + childWidth;
      subtreeWidth = Math.max(subtreeWidth, childWidth + siblingSpacing);
    });

    // Position spouse
    const spouse = getConnected(personId, REL.PARTNER)[0]; // Assume one primary
    if (spouse) {
      const spousePerson = newPeople.find(p => p.id === spouse);
      spousePerson.level = level;
      spousePerson.x = person.x - spouseOffset; // Left of main (RTL adjust)
      spousePerson.y = person.y;
      // Recurse spouse's other children if needed (complex; skip for v1)
    }

    // Parents (upward, limited to avoid cycles)
    if (level > -5) { // Limit ancestors
      const parents = getConnected(personId, REL.PARENT_CHILD).filter(p => /* parent logic */);
      // Similar recursion upward
    }

    return Math.max(CARD.w, subtreeWidth);
  };

  positionSubtree(rootId, 0);
  setPeople(newPeople);
  setPanOffset({ x: window.innerWidth / 2 - people.find(p => p.id === rootId)?.x * zoom, y: 100 }); // Center root
};

// Button in floating-controls
<Button onClick={() => computeLayout(selectedPerson?.id)} className="btn-emerald">
  {t.autoLayout || 'ترتيب تلقائي'}
</Button>

Why This Matches FamilyEcho: Recursive top-down positioning with horizontal spacing. Add overlap checks (shift x if |dx| < CARD.w). For full DAG (remarriages), use topological sort (simple array filter).



Render Connections with Styled SVG Lines (Fix "Not Working")

Overlay full-size SVG on tree-canvas. Draw per relationship, using card centers. Apply zoom/pan transform to lines.
Styles: Match your connectionOptions (thick/medium/gray). Use <path> for bends (e.g., L-shape for parent-child if not aligned).

jsx// Inside tree-canvas div, add:
<svg
  className="absolute inset-0 pointer-events-none"
  style={{ transform: `translate(${panOffset.x}px, ${panOffset.y}px) scale(${zoom})` }}
>
  {relationships.map(rel => {
    const p1 = people.find(p => p.id === rel.person1Id);
    const p2 = people.find(p => p.id === rel.person2Id);
    if (!p1 || !p2) return null;

    const x1 = p1.x + CARD.w / 2;
    const y1 = p1.y + (rel.type === REL.PARENT_CHILD ? CARD.h : CARD.h / 2); // Bottom for parent
    const x2 = p2.x + CARD.w / 2;
    const y2 = p2.y + (rel.type === REL.PARENT_CHILD ? 0 : CARD.h / 2); // Top for child

    let stroke = '#000', strokeWidth = 2, pathD = `M ${x1} ${y1} L ${x2} ${y2}`; // Straight default

    if (rel.type === REL.PARTNER) {
      strokeWidth = connectionOptions.currentPartners === 'thick' ? 4 : 2;
      pathD = `M ${x1} ${y1} H ${x2} ${y2}`; // Horizontal
    } else if (rel.type === REL.PARENT_CHILD) {
      strokeWidth = 3; // Medium
      // Sibling bar: If multiple children, draw horizontal at y2 - 10, but simplify to vertical + horizontal stub
      pathD = `M ${x1} ${y1} V ${(y1 + y2)/2} H ${x2} V ${y2}`; // L-bend to avoid cross
    } else if (rel.type === REL.SIBLING) {
      stroke = '#ccc'; strokeWidth = 1; // Thin gray
      pathD = `M ${x1} ${y1} L ${x2} ${y2}`; // Diagonal
    }

    if (rel.nonBiological) stroke = '#999'; // Dotted: add strokeDasharray="5,5"

    return <path key={rel.id} d={pathD} stroke={stroke} strokeWidth={strokeWidth * zoom} fill="none" />;
  })}
</svg>

Enhancements for FamilyEcho Match:

Sibling Bar: For parent-child groups, draw extra <line> horizontal at child level -10px, connecting all siblings' x.
Curves: Replace L with Q (quadratic bezier) for smooth bends: M ${x1} ${y1} Q ${(x1+x2)/2} ${(y1+y2)/2} ${x2} ${y2}.
Avoid Crosses: Post-layout, iterate lines and shift y/x by 20px if intersect (simple line-intersection math).
Update on zoom/pan: The transform handles it.





Add Drag-to-Connect and Generation Controls

For adding: On "Add Partner" click, set mode to drag from selected to target, create rel on drop.
Generation sliders: Use your generationOptions to limit computeLayout (e.g., parentsGenerations: 5).

jsx// Drag connect (add to card onClick)
const handleConnectDrag = (e, fromId, relType) => {
  // Set relationshipType, then on drop to another card, add to relationships
  setRelationshipType(relType);
  // ... e.dataTransfer.setData('fromId', fromId)
};


UI/Polish Changes (CSS + Options)

In App.css: Add .connection-line { stroke-linecap: round; } for rounded ends.
Expand connectionOptions: Add siblingBar: true.
RTL: In layout, reverse x-spacing (startX from right: window.innerWidth - startX).
Test: Add sample data with 2 parents, 3 children, 1 spouse. Run npm run dev.



These changes will make your connections functional and FamilyEcho-like (auto-clean layout, styled lines, no crosses). Total ~200 lines added. If overlaps persist in complex trees, consider a lib like dagre (add via npm). For full code merge, share untruncated App.jsx. Let me know for refinements!