Here's the revised code to fix both issues:
jsx{/* Parent-child relationships - Hierarchy chart style */}
{(() => {
  // Build a comprehensive map of parent-child relationships
  const childToParents = {};
  
  // First pass: collect all direct parent-child relationships
  relationships
    .filter((r) => r.type === REL.PARENT_CHILD && r.treeId === currentTree?.id)
    .forEach((r) => {
      const child = treePeople.find((p) => p.id === r.childId);
      const parent = treePeople.find((p) => p.id === r.parentId);
      
      if (!child || !parent) return;
      
      if (!childToParents[child.id]) {
        childToParents[child.id] = new Set();
      }
      childToParents[child.id].add(parent.id);
    });
  
  // Second pass: extend parents to siblings
  relationships
    .filter((r) => r.type === REL.SIBLING && r.treeId === currentTree?.id)
    .forEach((r) => {
      const person1Parents = childToParents[r.person1Id];
      const person2Parents = childToParents[r.person2Id];
      
      if (person1Parents && !person2Parents) {
        childToParents[r.person2Id] = new Set(person1Parents);
      } else if (person2Parents && !person1Parents) {
        childToParents[r.person1Id] = new Set(person2Parents);
      } else if (person1Parents && person2Parents) {
        const mergedParents = new Set([...person1Parents, ...person2Parents]);
        childToParents[r.person1Id] = mergedParents;
        childToParents[r.person2Id] = mergedParents;
      }
    });
  
  // Group children by their parent sets
  const parentGroups = {};
  
  Object.entries(childToParents).forEach(([childId, parentIds]) => {
    const parentArray = Array.from(parentIds).sort();
    const groupKey = parentArray.join('-');
    
    if (!parentGroups[groupKey]) {
      parentGroups[groupKey] = {
        parentIds: parentArray,
        children: []
      };
    }
    
    const child = treePeople.find(p => p.id === parseInt(childId));
    if (child) {
      parentGroups[groupKey].children.push(child);
    }
  });
  
  // Render connections for each parent group
  return Object.values(parentGroups).map((group, groupIndex) => {
    if (group.children.length === 0) return null;
    
    const parents = group.parentIds
      .map(id => treePeople.find(p => p.id === id))
      .filter(Boolean);
    
    if (parents.length === 0) return null;
    
    const children = group.children.sort((a, b) => a.x - b.x);
    
    let parentConnectionX, parentConnectionY;
    
    if (parents.length === 2) {
      const partnerRel = relationships.find(
        r => r.type === REL.PARTNER && 
        r.treeId === currentTree?.id &&
        ((r.person1Id === parents[0].id && r.person2Id === parents[1].id) ||
         (r.person1Id === parents[1].id && r.person2Id === parents[0].id))
      );
      
      if (partnerRel) {
        const p1X = parents[0].x + stylingOptions.boxWidth / 2;
        const p2X = parents[1].x + stylingOptions.boxWidth / 2;
        parentConnectionX = (p1X + p2X) / 2;
        parentConnectionY = Math.max(parents[0].y + CARD.h, parents[1].y + CARD.h);
      } else {
        parentConnectionX = parents[0].x + stylingOptions.boxWidth / 2;
        parentConnectionY = parents[0].y + CARD.h;
      }
    } else {
      parentConnectionX = parents[0].x + stylingOptions.boxWidth / 2;
      parentConnectionY = parents[0].y + CARD.h;
    }
    
    const childrenTopY = Math.min(...children.map(c => c.y));
    const horizontalLineY = parentConnectionY + (childrenTopY - parentConnectionY) / 2;
    
    const strokeColor = "#059669";
    const strokeWidth = 3;
    
    return (
      <g key={`parent-group-${groupIndex}`}>
        {/* Vertical line from parent connection point to horizontal bar */}
        <line
          x1={parentConnectionX}
          y1={parentConnectionY}
          x2={parentConnectionX}
          y2={horizontalLineY}
          stroke={strokeColor}
          strokeWidth={strokeWidth}
          strokeLinecap="round"
        />
        
        {/* Horizontal bar connecting to all children (if more than one) */}
        {children.length > 1 && (
          <line
            x1={children[0].x + stylingOptions.boxWidth / 2}
            y1={horizontalLineY}
            x2={children[children.length - 1].x + stylingOptions.boxWidth / 2}
            y2={horizontalLineY}
            stroke={strokeColor}
            strokeWidth={strokeWidth}
            strokeLinecap="round"
          />
        )}
        
        {/* Vertical lines from horizontal bar to each child */}
        {children.map((child, idx) => {
          const childCenterX = child.x + stylingOptions.boxWidth / 2;
          return (
            <line
              key={`child-${idx}`}
              x1={childCenterX}
              y1={horizontalLineY}
              x2={childCenterX}
              y2={child.y}
              stroke={strokeColor}
              strokeWidth={strokeWidth}
              strokeLinecap="round"
            />
          );
        })}
      </g>
    );
  });
})()}

{/* Sibling connections - ONLY for siblings WITHOUT shared parents */}
{(() => {
  // Find which children have parents (already connected via hierarchy)
  const childrenWithParents = new Set();
  relationships
    .filter((r) => r.type === REL.PARENT_CHILD && r.treeId === currentTree?.id)
    .forEach((r) => {
      childrenWithParents.add(r.childId);
    });
  
  // Group siblings without parents
  const siblingsWithoutParents = {};
  relationships
    .filter((r) => r.type === REL.SIBLING && r.treeId === currentTree?.id)
    .forEach((r) => {
      // Only show sibling line if NEITHER sibling has parents
      if (!childrenWithParents.has(r.person1Id) && !childrenWithParents.has(r.person2Id)) {
        const key = [r.person1Id, r.person2Id].sort().join('-');
        if (!siblingsWithoutParents[key]) {
          siblingsWithoutParents[key] = [r.person1Id, r.person2Id];
        }
      }
    });
  
  return Object.values(siblingsWithoutParents).map((siblingIds, i) => {
    const siblings = siblingIds
      .map(id => treePeople.find(p => p.id === id))
      .filter(Boolean)
      .sort((a, b) => a.x - b.x);
    
    if (siblings.length < 2) return null;

    const y = siblings[0].y - 20;
    const minX = Math.min(...siblings.map((s) => s.x + stylingOptions.boxWidth / 2));
    const maxX = Math.max(...siblings.map((s) => s.x + stylingOptions.boxWidth / 2));
    const curveHeight = 10;
    const strokeColor = "#7c3aed";
    const dashArray = "5,5";

    return (
      <g key={`siblings-orphan-${i}`}>
        <path
          d={`M ${minX} ${y} Q ${(minX + maxX) / 2} ${y - curveHeight} ${maxX} ${y}`}
          stroke={strokeColor}
          strokeWidth={2}
          strokeLinecap="round"
          strokeDasharray={dashArray}
          fill="none"
        />
        {siblings.map((sibling, idx) => {
          const siblingX = sibling.x + stylingOptions.boxWidth / 2;
          const connectionY = y - curveHeight * Math.sin((Math.PI * (siblingX - minX)) / (maxX - minX));
          return (
            <path
              key={`sibling-line-${idx}`}
              d={`M ${siblingX} ${connectionY} Q ${siblingX} ${(connectionY + sibling.y) / 2} ${siblingX} ${sibling.y}`}
              stroke={strokeColor}
              strokeWidth={2}
              strokeLinecap="round"
              fill="none"
            />
          );
        })}
      </g>
    );
  });
})()}
Key changes:

Fixed the gap: Changed horizontalLineY calculation to parentConnectionY + (childrenTopY - parentConnectionY) / 2 - this ensures the horizontal line is positioned exactly between the parents and children, creating a proper connection
Removed redundant sibling lines: Modified the sibling connection logic to ONLY draw dashed purple lines for siblings who DON'T have parents. If children share parents and are already connected via the hierarchy chart lines, the sibling connection won't be drawn

Now your family tree should show:

Clean hierarchy lines from parents to children
No redundant dashed sibling lines when children are already connected through parents
Proper connection between the vertical line from parents and the horizontal line connecting children