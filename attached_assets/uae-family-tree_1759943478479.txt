            <svg
              className="absolute inset-0 pointer-events-none"
              style={{
                width: "100%",
                height: "100%",
                transform: `translate(${panOffset.x}px, ${panOffset.y}px) scale(${zoom})`,
                transformOrigin: "0 0",
              }}
            >
              {(() => {
                const treeRels = relationships.filter(r => r.treeId === currentTree?.id);
                const elements = [];

                // 1. PARTNER LINES
                treeRels.filter(r => r.type === REL.PARTNER).forEach(rel => {
                  const p1 = treePeople.find(p => p.id === rel.person1Id);
                  const p2 = treePeople.find(p => p.id === rel.person2Id);
                  if (!p1 || !p2) return;

                  const midY = p1.y + CARD.h / 2;
                  elements.push(
                    <line
                      key={`spouse-${rel.id}`}
                      x1={p1.x + CARD.w / 2}
                      y1={midY}
                      x2={p2.x + CARD.w / 2}
                      y2={midY}
                      stroke="#8B8B8B"
                      strokeWidth={2 * zoom}
                    />
                  );
                });

                // 2. PARENT-CHILD CONNECTIONS
                Object.entries(parentCoupleGroups).forEach(([coupleKey, group]) => {
                  const childrenIds = Array.from(group.children);
                  if (childrenIds.length === 0) return;

                  const children = childrenIds.map(cid => treePeople.find(p => p.id === cid)).filter(Boolean);
                  if (children.length === 0) return;

                  const parents = group.parents.map(pid => treePeople.find(p => p.id === pid)).filter(Boolean);
                  if (parents.length === 0) return;

                  let parentsCenterX;
                  let parentsCenterY;
                  
                  if (parents.length === 2) {
                    parentsCenterX = (parents[0].x + CARD.w + parents[1].x) / 2;
                    parentsCenterY = parents[0].y + CARD.h;
                  } else {
                    parentsCenterX = parents[0].x + CARD.w / 2;
                    parentsCenterY = parents[0].y + CARD.h;
                  }

                  if (children.length === 1) {
                    // SINGLE CHILD: Direct line from parents to child
                    const child = children[0];
                    const childCenterX = child.x + CARD.w / 2;
                    const childTopY = child.y;

                    elements.push(
                      <line
                        key={`parent-child-${coupleKey}`}
                        x1={parentsCenterX}
                        y1={parentsCenterY}
                        x2={childCenterX}
                        y2={childTopY}
                        stroke="#8B8B8B"
                        strokeWidth={2 * zoom}
                      />
                    );
                  } else {
                    // MULTIPLE CHILDREN: Hierarchy diagram
                    const childXPositions = children.map(c => c.x + CARD.w / 2);
                    const barX1 = Math.min(...childXPositions);
                    const barX2 = Math.max(...childXPositions);
                    const barY = parentsCenterY + 40;
                    const barCenterX = (barX1 + barX2) / 2;

                    // Vertical line from parents to bar
                    elements.push(
                      <line
                        key={`parent-to-bar-${coupleKey}`}
                        x1={parentsCenterX}
                        y1={parentsCenterY}
                        x2={barCenterX}
                        y2={barY}
                        stroke="#8B8B8B"
                        strokeWidth={2 * zoom}
                      />
                    );

                    // Horizontal bar
                    elements.push(
                      <line
                        key={`sibling-bar-${coupleKey}`}
                        x1={barX1}
                        y1={barY}
                        x2={barX2}
                        y2={barY}
                        stroke="#8B8B8B"
                        strokeWidth={2 * zoom}
                      />
                    );

                    // Vertical drops to each child
                    children.forEach(child => {
                      const childCenterX = child.x + CARD.w / 2;
                      const childTopY = child.y;

                      elements.push(
                        <line
                          key={`bar-to-child-${coupleKey}-${child.id}`}
                          x1={childCenterX}
                          y1={barY}
                          x2={childCenterX}
                          y2={childTopY}
                          stroke="#8B8B8B"
                          strokeWidth={2 * zoom}
                        />
                      );
                    });
                  }
                });

                // 3. SIBLING LINES
                treeRels.filter(r => r.type === REL.SIBLING).forEach(rel => {
                  const p1 = treePeople.find(p => p.id === rel.person1Id);
                  const p2 = treePeople.find(p => p.id === rel.person2Id);
                  if (!p1 || !p2) return;

                  const alreadyConnected = Object.values(parentCoupleGroups).some(group => {
                    const childrenIds = Array.from(group.children);
                    return childrenIds.includes(p1.id) && childrenIds.includes(p2.id);
                  });

                  if (!alreadyConnected) {
                    const y = Math.min(p1.y, p2.y) + CARD.h / 2;
                    elements.push(
                      <line
                        key={`sibling-${rel.id}`}
                        x1={p1.x + CARD.w / 2}
                        y1={y}
                        x2={p2.x + CARD.w / 2}
                        y2={y}
                        stroke="#ccc"
                        strokeWidth={1 * zoom}
                      />
                    );
                  }
                });

                return elements;
              })()}
            </svg>